/* 
1). 2个引用变量指向同个对象, 通过一个引用变量改变对象内部的数据, 另一个引用变量看到的新的
2). 2个引用变量指向同个对象, 让一个引用变量指向一个新的对象, 另一个引用变量看到的还是原来的对象!
*/
// const o1 = {m: 1}
// const o2 = o1
// o1.m = 2
// console.log(o2.m) // 2

let o3 = {m: 1}
let o4 = o3
// o3 = {m: 2}
// console.log(o4.m) // 1
/* 实参和形参虽然同名,但是相当于将实参的引用地址拷贝了一份额外给了形参
此时,相当于有两个同名变量指向内存中的同一个地址,函数内部同名形参若重新进行赋值而不是修改时
就会使该同名形参的内存中指向地址发生改变指向新的对象,外部同名变量指向不变 */
function fn(o4) {     
  // o4.m = 3
  o4 = {m: 3}
}

fn(o4)    // 引用类型,实际上只是将它的值赋值给形参了一份!!你管他形参长啥样,只看形参指向该内存地址后,如何进行修改,
          // 若是点语法修改属性,则内外都看到了变化; 若时重新赋值,则内部不会影响到外部
console.log(o3.m, o4.m)   // 1 1
a = 2
fn(a)     // 值传递
console.log(o3.m, o4.m)

